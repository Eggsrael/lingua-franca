// Test of lf_update_deadline() API for updating deadlines dynamically.
// This test covers two scenarios:
// 1. Updating to an earlier deadline: Verify that a 100 ms declared deadline
// can be shortened to 50 ms at runtime, and that a violation occurs
// accordingly.
// 2-1. Updating to a later deadline: Verify that a 50 ms declared deadline
// can be relaxed to 100 ms at runtime, and violation is triggered at
// the updated time 100 ms.
// 2-2. Test if the updated deadline is applied when the same reaction is
// triggered again, even without calling the lf_update_deadline function.
target C

reactor A {
  state updated: bool = false
  logical action a

  // Test Case 1: Verify that decreasing the deadline works.
  // The reaction starts with a declared deadline of 100 ms, but we update it
  // to 50 ms at runtime. A deadline violation should therefore be detected
  // around physical time 50 ms. If no violation is detected
  // after 50 ms, the test fails.
  reaction(startup) -> a {=
    lf_update_deadline(self, MSEC(50));
    lf_sleep(MSEC(50));
    if(!lf_check_deadline(self, true)){
      lf_print_error_and_exit("Updating deadline failed. Deadline handler was not invoked on lag of 50 msec.");
    } else{
      lf_print("Test1 Success: Updating deadline from 100 ms to 50 ms success.\n");
    }
  =} deadline(100 msec) {=
    // With the updated deadline, this handler should fire around 50 ms of lag.
    lf_print("Deadline violation detected on Logical time: %lld msecs. Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_time_physical_elapsed() / MSEC(1));
    lf_schedule(a, MSEC(100)); // Reset lag.
  =}

  // Test Case 2-1: Verify that increasing the deadline works.
  // The reaction is declared with a 50 ms deadline, but we update it
  // to 100 ms at runtime. A violation should NOT be detected at 50 ms,
  // because the updated deadline is 100 ms. Entering the deadline
  // handler below would indicate failure.

  // Test Case 2-2: Verify if the updated deadline takes effect in the
  // subsequent reaction, even when the lf_update_deadline function is not invoked.
  reaction(a) {=
    if (!self->updated) {
      // Increase deadline to 100 msec.
      lf_update_deadline(self, MSEC(100));
    }
    lf_sleep(MSEC(50));
    if (lf_check_deadline(self, true)){
      // Deadline handler should bot be invoked here.
      lf_print_error_and_exit("Deadline was not updated to 100 msec.");
    } else {
      lf_sleep(MSEC(50));
      if (lf_check_deadline(self, true)){
        if (!self->updated) {
          lf_print("Test2-1 Success: Updating deadline from 50 ms to 100 ms success.\n");
        } else {
          lf_print("Test2-2 Success: Updated deadline from 50 ms to 100 ms was saved.\n");
        }
      }
      self->updated = true;
    }
  =} deadline(50 msec) {=
    lf_print("Deadline violation detected on Logical time: %lld msecs. Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_time_physical_elapsed() / MSEC(1));
    if (!self->updated) {
      // Test if the deadline is updated in the next reaction, even when lf_update_deadline() was not called again.
      lf_schedule(a, MSEC(100));
    }
  =}
}

main reactor {
  a = new A()
}
